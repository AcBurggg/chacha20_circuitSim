# chacha20_circuitSim

## Background Information
chacha20.sim can be opened using CS2110-CircuitSim.jar - a modification of the software found [here](https://github.com/ra4king/CircuitSim).

In this file is a circuitry implementation of the chacha20 block function as described in this [RFC document](https://www.rfc-editor.org/rfc/rfc7539). 
Note that a more broad overview can be found on the [Salsa20 wikipedia page](https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant). To the best of my
knowledge, the wikipedia page describes creator Daniel Bernstein's implementation while the RFC document (that I based my design on) is the IETF's modified
design. This slightly altered version decreases the length of the counter from 64-bits to 32-bits and increases the length of the nonce from 64-bits to 96-bits. 
Only the initial matrix state changes - the logic of the block_function is unchanged.

Currently, the "intitial state" of the input matrix is represented by 16 32-bit circuitSim constant pins at the top of the main subcircuit. The fields that can be altered are as follows: key0-key7, counter, and nonce0-2. The constant is a nothing-up-my-sleeve-number and should not be changed to maintain integriy. It is the ASCII value of "expand 32-byte k".

The block function's purpose is to generate a long keystream that can then be XOR'd with a plaintext input to get a ciphertext. Ciphers using this counter (CTR) mode of operation are thus quite similar to stream ciphers that use a one-time-pad. The "block" part is merely for generating the keystream. 

In addition to generating this keystream, the main subcircuit also supports the actual encryption process. To see this visualized, run the hex_generator.py file to generate a hexoutput.dat file that can be loaded into the ROM in the main subcircuit. This python script can be run with "python3 hex_generator.py --file "/path/to/file.txt"" or "python3 hex_generator.py --text "string to encrypt example"". 

Currently, the circuitry is able to generate 512 bits of keystream at once meaning that strings to be encrypted should be limited to (512 / 8 bits per ascii char) 64 characters or fewer. In real life, the benefit of CTR would allow 2^32 * 512 bits to be generated easily by incrementing the counter value and running the block function again- this functionality has not (yet) been implemented in my .sim file. 


To load the hex ASCII of your string into the circuitry, right click on the ROM and select "edit contents". Then select "load from file" and select the hexoutput.dat file that should have been generated by running the python script. Then manually tick the simulation via shift clicking on the clock icon to view the encrypted ciphertext presented on the red hex displays. To reset the simulation, press Command+R. 


## User Guide